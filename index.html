<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
   <link rel="stylesheet" href="loaging.css">
   <style>
      .system-initialization {
         font-size: 20px;
         color: #FFFFFF;
         font-family: 'Courier New', Courier, monospace;
         font-variant: small-caps;
      }
      h1 {
         color: #FFFFFF;
         text-align: center;
         font-size: 40px;
         padding: 0px;
         font-weight: bold;
         font-family: 'Courier New', Courier, monospace;
      }

      #typing-text {
         color: #FFFFFF;
         border: double 7px #A8A8A8;
         font-weight: bold;
         text-align: left;
         font-family: Arial, Helvetica, sans-serif;
         overflow: hidden;
         background-color: #251f1c;
         font-size: 11px;
         padding: 35px;
         height: 100%;
         width: 100%;
         outline: none;
         resize: none;
         box-sizing: border-box;
      }

      .ashe-border {
         border: double 7px #A8A8A8;
         background-color: #251f1c;
      }

      .unit {
         color: #fa7064;
         font-weight: italic;
      }
   </style>
</head>

<body background="backg.jpeg">
   <audio autoplay loop>
     <source src="backg.mp3">
   </audio>
   <h1>A.S.H.E. <div class="unit">unit G105118</div>
   </h1>
   <!-- www.html-code-generator.com-->
   <textarea id="typing-text" readonly></textarea>
   <p align="middle"><img class="ashe-border" src="ashe.png" alt="A.S.H.E."></p>
   <script>
      (function () {
         var CharacterPos = 0;
         var MsgBuffer = "";
         var TypeDelay = 1;
         var NxtMsgDelay = 200;
         var MsgIndex = 0;
         var delay;
         var MsgArray = ["#include \"precompiled.h\"\n#include \"NetClient.h\"\n#include \"NetClientTurnManager.h\"\n#include \"NetMessage.h\"\n#include \"NetSession.h\"\n#include \"lib/byte_order.h\"\n#include \"lib/external_libraries/enet.h\"\n#include \"lib/sysdep/sysdep.h\"\n#include \"lobby/IXmppClient.h\"\n#include \"ps/CConsole.h\"\n#include \"ps/CLogger.h\"\n#include \"ps/Compress.h\"\n#include \"ps/CStr.h\"\n#include \"ps/Game.h\"\n#include \"ps/Loader.h\"\n#include \"scriptinterface/ScriptInterface.h\"\n#include \"simulation2/Simulation2.h\"\n\nCNetClient *g_NetClient = NULL;\n\n/**\n * Async task for receiving the initial game state when rejoining an\n * in-progress network game.\n */\nclass CNetFileReceiveTask_ClientRejoin : public CNetFileReceiveTask\n{\n\tNONCOPYABLE(CNetFileReceiveTask_ClientRejoin);\npublic:\n\tCNetFileReceiveTask_ClientRejoin(CNetClient& client)\n\t\t: m_Client(client)\n\t{\n\t}\n\n\tvirtual void OnComplete()\n\t{\n\t\t// We've received the game state from the server\n\n\t\t// Save it so we can use it after the map has finished loading\n\t\tm_Client.m_JoinSyncBuffer = m_Buffer;\n\n\t\t// Pretend the server told us to start the game\n\t\tCGameStartMessage start;\n\t\tm_Client.HandleMessage(&start);\n\t}\n\nprivate:\n\tCNetClient& m_Client;\n};\n\nCNetClient::CNetClient(CGame* game, bool isLocalClient) :\n\tm_Session(NULL),\n\tm_UserName(L\"anonymous\"),\n\tm_HostID((u32)-1), m_ClientTurnManager(NULL), m_Game(game),\n\tm_GameAttributes(game->GetSimulation2()->GetScriptInterface().GetContext()),\n\tm_IsLocalClient(isLocalClient),\n\tm_LastConnectionCheck(0),\n\tm_Rejoin(false)\n{\n\tm_Game->SetTurnManager(NULL); // delete the old local turn manager so we don't accidentally use it\n\n\tvoid* context = this;\n\n\tJS_AddExtraGCRootsTracer(GetScriptInterface().GetJSRuntime(), CNetClient::Trace, this);\n\n\t// Set up transitions for session\n\tAddTransition(NCS_UNCONNECTED, (uint)NMT_CONNECT_COMPLETE, NCS_CONNECT, (void*)&OnConnect, context);\n\n\tAddTransition(NCS_CONNECT, (uint)NMT_SERVER_HANDSHAKE, NCS_HANDSHAKE, (void*)&OnHandshake, context);\n\n\tAddTransition(NCS_HANDSHAKE, (uint)NMT_SERVER_HANDSHAKE_RESPONSE, NCS_AUTHENTICATE, (void*)&OnHandshakeResponse, context);\n\n\tAddTransition(NCS_AUTHENTICATE, (uint)NMT_AUTHENTICATE, NCS_AUTHENTICATE, (void*)&OnAuthenticateRequest, context);\n\tAddTransition(NCS_AUTHENTICATE, (uint)NMT_AUTHENTICATE_RESULT, NCS_INITIAL_GAMESETUP, (void*)&OnAuthenticate, context);\n\n\tAddTransition(NCS_INITIAL_GAMESETUP, (uint)NMT_GAME_SETUP, NCS_PREGAME, (void*)&OnGameSetup, context);\n\n\tAddTransition(NCS_PREGAME, (uint)NMT_CHAT, NCS_PREGAME, (void*)&OnChat, context);\n\tAddTransition(NCS_PREGAME, (uint)NMT_READY, NCS_PREGAME, (void*)&OnReady, context);\n\tAddTransition(NCS_PREGAME, (uint)NMT_GAME_SETUP, NCS_PREGAME, (void*)&OnGameSetup, context);\n\tAddTransition(NCS_PREGAME, (uint)NMT_PLAYER_ASSIGNMENT, NCS_PREGAME, (void*)&OnPlayerAssignment, context);\n\tAddTransition(NCS_PREGAME, (uint)NMT_KICKED, NCS_PREGAME, (void*)&OnKicked, context);\n\tAddTransition(NCS_PREGAME, (uint)NMT_CLIENT_TIMEOUT, NCS_PREGAME, (void*)&OnClientTimeout, context);\n\tAddTransition(NCS_PREGAME, (uint)NMT_CLIENT_PERFORMANCE, NCS_PREGAME, (void*)&OnClientPerformance, context);\n\tAddTransition(NCS_PREGAME, (uint)NMT_GAME_START, NCS_LOADING, (void*)&OnGameStart, context);\n\tAddTransition(NCS_PREGAME, (uint)NMT_JOIN_SYNC_START, NCS_JOIN_SYNCING, (void*)&OnJoinSyncStart, context);\n\n\tAddTransition(NCS_JOIN_SYNCING, (uint)NMT_CHAT, NCS_JOIN_SYNCING, (void*)&OnChat, context);\n\tAddTransition(NCS_JOIN_SYNCING, (uint)NMT_GAME_SETUP, NCS_JOIN_SYNCING, (void*)&OnGameSetup, context);\n\tAddTransition(NCS_JOIN_SYNCING, (uint)NMT_PLAYER_ASSIGNMENT, NCS_JOIN_SYNCING, (void*)&OnPlayerAssignment, context);\n\tAddTransition(NCS_JOIN_SYNCING, (uint)NMT_KICKED, NCS_JOIN_SYNCING, (void*)&OnKicked, context);\n\tAddTransition(NCS_JOIN_SYNCING, (uint)NMT_CLIENT_TIMEOUT, NCS_JOIN_SYNCING, (void*)&OnClientTimeout, context);\n\tAddTransition(NCS_JOIN_SYNCING, (uint)NMT_CLIENT_PERFORMANCE, NCS_JOIN_SYNCING, (void*)&OnClientPerformance, context);\n\tAddTransition(NCS_JOIN_SYNCING, (uint)NMT_GAME_START, NCS_JOIN_SYNCING, (void*)&OnGameStart, context);\n\tAddTransition(NCS_JOIN_SYNCING, (uint)NMT_SIMULATION_COMMAND, NCS_JOIN_SYNCING, (void*)&OnInGame, context);\n\tAddTransition(NCS_JOIN_SYNCING, (uint)NMT_END_COMMAND_BATCH, NCS_JOIN_SYNCING, (void*)&OnJoinSyncEndCommandBatch, context);\n\tAddTransition(NCS_JOIN_SYNCING, (uint)NMT_LOADED_GAME, NCS_INGAME, (void*)&OnLoadedGame, context);\n\n\tAddTransition(NCS_LOADING, (uint)NMT_CHAT, NCS_LOADING, (void*)&OnChat, context);\n\tAddTransition(NCS_LOADING, (uint)NMT_GAME_SETUP, NCS_LOADING, (void*)&OnGameSetup, context);\n\tAddTransition(NCS_LOADING, (uint)NMT_PLAYER_ASSIGNMENT, NCS_LOADING, (void*)&OnPlayerAssignment, context);\n\tAddTransition(NCS_LOADING, (uint)NMT_KICKED, NCS_LOADING, (void*)&OnKicked, context);\n\tAddTransition(NCS_LOADING, (uint)NMT_CLIENT_TIMEOUT, NCS_LOADING, (void*)&OnClientTimeout, context);\n\tAddTransition(NCS_LOADING, (uint)NMT_CLIENT_PERFORMANCE, NCS_LOADING, (void*)&OnClientPerformance, context);\n\tAddTransition(NCS_LOADING, (uint)NMT_CLIENTS_LOADING, NCS_LOADING, (void*)&OnClientsLoading, context);\n\tAddTransition(NCS_LOADING, (uint)NMT_LOADED_GAME, NCS_INGAME, (void*)&OnLoadedGame, context);\n\n\tAddTransition(NCS_INGAME, (uint)NMT_REJOINED, NCS_INGAME, (void*)&OnRejoined, context);\n\tAddTransition(NCS_INGAME, (uint)NMT_KICKED, NCS_INGAME, (void*)&OnKicked, context);\n\tAddTransition(NCS_INGAME, (uint)NMT_CLIENT_TIMEOUT, NCS_INGAME, (void*)&OnClientTimeout, context);\n\tAddTransition(NCS_INGAME, (uint)NMT_CLIENT_PERFORMANCE, NCS_INGAME, (void*)&OnClientPerformance, context);\n\tAddTransition(NCS_INGAME, (uint)NMT_CLIENTS_LOADING, NCS_INGAME, (void*)&OnClientsLoading, context);\n\tAddTransition(NCS_INGAME, (uint)NMT_CLIENT_PAUSED, NCS_INGAME, (void*)&OnClientPaused, context);\n\tAddTransition(NCS_INGAME, (uint)NMT_CHAT, NCS_INGAME, (void*)&OnChat, context);\n\tAddTransition(NCS_INGAME, (uint)NMT_GAME_SETUP, NCS_INGAME, (void*)&OnGameSetup, context);\n\tAddTransition(NCS_INGAME, (uint)NMT_PLAYER_ASSIGNMENT, NCS_INGAME, (void*)&OnPlayerAssignment, context);\n\tAddTransition(NCS_INGAME, (uint)NMT_SIMULATION_COMMAND, NCS_INGAME, (void*)&OnInGame, context);\n\tAddTransition(NCS_INGAME, (uint)NMT_SYNC_ERROR, NCS_INGAME, (void*)&OnInGame, context);\n\tAddTransition(NCS_INGAME, (uint)NMT_END_COMMAND_BATCH, NCS_INGAME, (void*)&OnInGame, context);\n\n\t// Set first state\n\tSetFirstState(NCS_UNCONNECTED);\n}\n\nCNetClient::~CNetClient()\n{\n\tDestroyConnection();\n\tJS_RemoveExtraGCRootsTracer(GetScriptInterface().GetJSRuntime(), CNetClient::Trace, this);\n}\n\nvoid CNetClient::TraceMember(JSTracer *trc)\n{\n\tfor (JS::Heap<JS::Value>& guiMessage : m_GuiMessageQueue)\n\t\tJS_CallValueTracer(trc, &guiMessage, \"m_GuiMessageQueue\");\n}\n\nvoid CNetClient::SetUserName(const CStrW& username)\n{\n\tENSURE(!m_Session); // must be called before we start the connection\n\n\tm_UserName = username;\n}\n\nvoid CNetClient::SetHostingPlayerName(const CStr& hostingPlayerName)\n{\n\tm_HostingPlayerName = hostingPlayerName;\n}\n\nbool CNetClient::SetupConnection(const CStr& server, const u16 port, ENetHost* enetClient)\n{\n\tCNetClientSession* session = new CNetClientSession(*this);\n\tbool ok = session->Connect(server, port, m_IsLocalClient, enetClient);\n\tSetAndOwnSession(session);\n\treturn ok;\n}\n\nvoid CNetClient::SetAndOwnSession(CNetClientSession* session)\n{\n\tdelete m_Session;\n\tm_Session = session;\n}\n\nvoid CNetClient::DestroyConnection()\n{\n\t// Attempt to send network messages from the current frame before connection is destroyed.\n\tif (m_ClientTurnManager)\n\t{\n\t\tm_ClientTurnManager->OnDestroyConnection();\n\t\tFlush();\n\t}\n\tSAFE_DELETE(m_Session);\n}\n\nvoid CNetClient::Poll()\n{\n\tif (!m_Session)\n\t\treturn;\n\n\tCheckServerConnection();\n\tm_Session->Poll();\n}\n\nvoid CNetClient::CheckServerConnection()\n{\n\t// Trigger local warnings if the connection to the server is bad.\n\t// At most once per second.\n\tstd::time_t now = std::time(nullptr);\n\tif (now <= m_LastConnectionCheck)\n\t\treturn;\n\n\tm_LastConnectionCheck = now;\n\n\t// Report if we are losing the connection to the server\n\tu32 lastReceived = m_Session->GetLastReceivedTime();\n\tif (lastReceived > NETWORK_WARNING_TIMEOUT)\n\t{\n\t\tPushGuiMessage(\n\t\t\t\"type\", \"netwarn\",\n\t\t\t\"warntype\", \"server-timeout\",\n\t\t\t\"lastReceivedTime\", lastReceived);\n\t\treturn;\n\t}\n\n\t// Report if we have a bad ping to the server\n\tu32 meanRTT = m_Session->GetMeanRTT();\n\tif (meanRTT > DEFAULT_TURN_LENGTH_MP)\n\t{\n\t\tPushGuiMessage(\n\t\t\t\"type\", \"netwarn\",\n\t\t\t\"warntype\", \"server-latency\",\n\t\t\t\"meanRTT\", meanRTT);\n\t}\n}\n\nvoid CNetClient::Flush()\n{\n\tif (m_Session)\n\t\tm_Session->Flush();\n}\n\nvoid CNetClient::GuiPoll(JS::MutableHandleValue ret)\n{\n\tif (m_GuiMessageQueue.empty())\n\t{\n\t\tret.setUndefined();\n\t\treturn;\n\t}\n\n\tret.set(m_GuiMessageQueue.front());\n\tm_GuiMessageQueue.pop_front();\n}\n\nstd::string CNetClient::TestReadGuiMessages()\n{\n\tJSContext* cx = GetScriptInterface().GetContext();\n\tJSAutoRequest rq(cx);\n\n\tstd::string r;\n\tJS::RootedValue msg(cx);\n\twhile (true)\n\t{\n\t\tGuiPoll(&msg);\n\t\tif (msg.isUndefined())\n\t\t\tbreak;\n\t\tr += GetScriptInterface().ToString(&msg) + \"\\n\";\n\t}\n\treturn r;\n}\n\nconst ScriptInterface& CNetClient::GetScriptInterface()\n{\n\treturn m_Game->GetSimulation2()->GetScriptInterface();\n}\n\nvoid CNetClient::PostPlayerAssignmentsToScript()\n{\n\tJSContext* cx = GetScriptInterface().GetContext();\n\tJSAutoRequest rq(cx);\n\n\tJS::RootedValue newAssignments(cx);\n\tScriptInterface::CreateObject(cx, &newAssignments);\n\n\tfor (const std::pair<CStr, PlayerAssignment>& p : m_PlayerAssignments)\n\t{\n\t\tJS::RootedValue assignment(cx);\n\n\t\tScriptInterface::CreateObject(\n\t\t\tcx,\n\t\t\t&assignment,\n\t\t\t\"name\", p.second.m_Name,\n\t\t\t\"player\", p.second.m_PlayerID,\n\t\t\t\"status\", p.second.m_Status);\n\n\t\tGetScriptInterface().SetProperty(newAssignments, p.first.c_str(), assignment);\n\t}\n\n\tPushGuiMessage(\n\t\t\"type\", \"players\",\n\t\t\"newAssignments\", newAssignments);\n}\n\nbool CNetClient::SendMessage(const CNetMessage* message)\n{\n\tif (!m_Session)\n\t\treturn false;\n\n\treturn m_Session->SendMessage(message);\n}\n\nvoid CNetClient::HandleConnect()\n{\n\tUpdate((uint)NMT_CONNECT_COMPLETE, NULL);\n}\n\nvoid CNetClient::HandleDisconnect(u32 reason)\n{\n\tPushGuiMessage(\n\t\t\"type\", \"netstatus\",\n\t\t\"status\", \"disconnected\",\n\t\t\"reason\", reason);\n\n\tSAFE_DELETE(m_Session);\n\n\t// Update the state immediately to UNCONNECTED (don't bother with FSM transitions since\n\t// we'd need one for every single state, and we don't need to use per-state actions)\n\tSetCurrState(NCS_UNCONNECTED);\n}\n\nvoid CNetClient::SendGameSetupMessage(JS::MutableHandleValue attrs, const ScriptInterface& scriptInterface)\n{\n\tCGameSetupMessage gameSetup(scriptInterface);\n\tgameSetup.m_Data = attrs;\n\tSendMessage(&gameSetup);\n}\n\nvoid CNetClient::SendAssignPlayerMessage(const int playerID, const CStr& guid)\n{\n\tCAssignPlayerMessage assignPlayer;\n\tassignPlayer.m_PlayerID = playerID;\n\tassignPlayer.m_GUID = guid;\n\tSendMessage(&assignPlayer);\n}\n\nvoid CNetClient::SendChatMessage(const std::wstring& text)\n{\n\tCChatMessage chat;\n\tchat.m_Message = text;\n\tSendMessage(&chat);\n}\n\nvoid CNetClient::SendReadyMessage(const int status)\n{\n\tCReadyMessage readyStatus;\n\treadyStatus.m_Status = status;\n\tSendMessage(&readyStatus);\n}\n\nvoid CNetClient::SendClearAllReadyMessage()\n{\n\tCClearAllReadyMessage clearAllReady;\n\tSendMessage(&clearAllReady);\n}\n\nvoid CNetClient::SendStartGameMessage()\n{\n\tCGameStartMessage gameStart;\n\tSendMessage(&gameStart);\n}\n\nvoid CNetClient::SendRejoinedMessage()\n{\n\tCRejoinedMessage rejoinedMessage;\n\tSendMessage(&rejoinedMessage);\n}\n\nvoid CNetClient::SendKickPlayerMessage(const CStrW& playerName, bool ban)\n{\n\tCKickedMessage kickPlayer;\n\tkickPlayer.m_Name = playerName;\n\tkickPlayer.m_Ban = ban;\n\tSendMessage(&kickPlayer);\n}\n\nvoid CNetClient::SendPausedMessage(bool pause)\n{\n\tCClientPausedMessage pausedMessage;\n\tpausedMessage.m_Pause = pause;\n\tSendMessage(&pausedMessage);\n}\n\nbool CNetClient::HandleMessage(CNetMessage* message)\n{\n\t// Handle non-FSM messages first\n\n\tStatus status = m_Session->GetFileTransferer().HandleMessageReceive(*message);\n\tif (status == INFO::OK)\n\t\treturn true;\n\tif (status != INFO::SKIPPED)\n\t\treturn false;\n\n\tif (message->GetType() == NMT_FILE_TRANSFER_REQUEST)\n\t{\n\t\tCFileTransferRequestMessage* reqMessage = static_cast<CFileTransferRequestMessage*>(message);\n\n\t\t// TODO: we should support different transfer request types, instead of assuming\n\t\t// it's always requesting the simulation state\n\n\t\tstd::stringstream stream;\n\n\t\tLOGMESSAGERENDER(\"Serializing game at turn %u for rejoining player\", m_ClientTurnManager->GetCurrentTurn());\n\t\tu32 turn = to_le32(m_ClientTurnManager->GetCurrentTurn());\n\t\tstream.write((char*)&turn, sizeof(turn));\n\n\t\tbool ok = m_Game->GetSimulation2()->SerializeState(stream);\n\t\tENSURE(ok);\n\n\t\t// Compress the content with zlib to save bandwidth\n\t\t// (TODO: if this is still too large, compressing with e.g. LZMA works much better)\n\t\tstd::string compressed;\n\t\tCompressZLib(stream.str(), compressed, true);\n\n\t\tm_Session->GetFileTransferer().StartResponse(reqMessage->m_RequestID, compressed);\n\n\t\treturn true;\n\t}\n\n\t// Update FSM\n\tbool ok = Update(message->GetType(), message);\n\tif (!ok)\n\t\tLOGERROR(\"Net client: Error running FSM update (type=%d state=%d)\", (int)message->GetType(), (int)GetCurrState());\n\treturn ok;\n}\n\nvoid CNetClient::LoadFinished()\n{\n\tif (!m_JoinSyncBuffer.empty())\n\t{\n\t\t// We're rejoining a game, and just finished loading the initial map,\n\t\t// so deserialize the saved game state now\n\n\t\tstd::string state;\n\t\tDecompressZLib(m_JoinSyncBuffer, state, true);\n\n\t\tstd::stringstream stream(state);\n\n\t\tu32 turn;\n\t\tstream.read((char*)&turn, sizeof(turn));\n\t\tturn = to_le32(turn);\n\n\t\tLOGMESSAGE(\"Rejoining client deserializing state at turn %u\\n\", turn);\n\n\t\tbool ok = m_Game->GetSimulation2()->DeserializeState(stream);\n\t\tENSURE(ok);\n\n\t\tm_ClientTurnManager->ResetState(turn, turn);\n\n\t\tPushGuiMessage(\n\t\t\t\"type\", \"netstatus\",\n\t\t\t\"status\", \"join_syncing\");\n\t}\n\telse\n\t{\n\t\t// Connecting at the start of a game, so we'll wait for other players to finish loading\n\t\tPushGuiMessage(\n\t\t\t\"type\", \"netstatus\",\n\t\t\t\"status\", \"waiting_for_players\");\n\t}\n\n\tCLoadedGameMessage loaded;\n\tloaded.m_CurrentTurn = m_ClientTurnManager->GetCurrentTurn();\n\tSendMessage(&loaded);\n}\n\nvoid CNetClient::SendAuthenticateMessage()\n{\n\tCAuthenticateMessage authenticate;\n\tauthenticate.m_Name = m_UserName;\n\tauthenticate.m_Password = L\"\"; // TODO\n\tauthenticate.m_IsLocalClient = m_IsLocalClient;\n\tSendMessage(&authenticate);\n}\n\nbool CNetClient::OnConnect(void* context, CFsmEvent* event)\n{\n\tENSURE(event->GetType() == (uint)NMT_CONNECT_COMPLETE);\n\n\tCNetClient* client = static_cast<CNetClient*>(context);\n\n\tclient->PushGuiMessage(\n\t\t\"type\", \"netstatus\",\n\t\t\"status\", \"connected\");\n\n\treturn true;\n}\n\nbool CNetClient::OnHandshake(void* context, CFsmEvent* event)\n{\n\tENSURE(event->GetType() == (uint)NMT_SERVER_HANDSHAKE);\n\n\tCNetClient* client = static_cast<CNetClient*>(context);\n\n\tCCliHandshakeMessage handshake;\n\thandshake.m_MagicResponse = PS_PROTOCOL_MAGIC_RESPONSE;\n\thandshake.m_ProtocolVersion = PS_PROTOCOL_VERSION;\n\thandshake.m_SoftwareVersion = PS_PROTOCOL_VERSION;\n\tclient->SendMessage(&handshake);\n\n\treturn true;\n}\n\nbool CNetClient::OnHandshakeResponse(void* context, CFsmEvent* event)\n{\n\tENSURE(event->GetType() == (uint)NMT_SERVER_HANDSHAKE_RESPONSE);\n\n\tCNetClient* client = static_cast<CNetClient*>(context);\n\tCSrvHandshakeResponseMessage* message = static_cast<CSrvHandshakeResponseMessage*>(event->GetParamRef());\n\n\tclient->m_GUID = message->m_GUID;\n\n\tif (message->m_Flags & PS_NETWORK_FLAG_REQUIRE_LOBBYAUTH)\n\t{\n\t\tif (g_XmppClient && !client->m_HostingPlayerName.empty())\n\t\t\tg_XmppClient->SendIqLobbyAuth(client->m_HostingPlayerName, client->m_GUID);\n\t\telse\n\t\t{\n\t\t\tclient->PushGuiMessage(\n\t\t\t\t\"type\", \"netstatus\",\n\t\t\t\t\"status\", \"disconnected\",\n\t\t\t\t\"reason\", static_cast<i32>(NDR_LOBBY_AUTH_FAILED));\n\n\t\t\tLOGMESSAGE(\"Net client: Couldn't send lobby auth xmpp message\");\n\t\t}\n\t\treturn true;\n\t}\n\n\tclient->SendAuthenticateMessage();\n\treturn true;\n}\n\nbool CNetClient::OnAuthenticateRequest(void* context, CFsmEvent* event)\n{\n\tENSURE(event->GetType() == (uint)NMT_AUTHENTICATE);\n\n\tCNetClient* client = static_cast<CNetClient*>(context);\n\tclient->SendAuthenticateMessage();\n\treturn true;\n}\n\nbool CNetClient::OnAuthenticate(void* context, CFsmEvent* event)\n{\n\tENSURE(event->GetType() == (uint)NMT_AUTHENTICATE_RESULT);\n\n\tCNetClient* client = static_cast<CNetClient*>(context);\n\tCAuthenticateResultMessage* message = static_cast<CAuthenticateResultMessage*>(event->GetParamRef());\n\n\tLOGMESSAGE(\"Net: Authentication result: host=%u, %s\", message->m_HostID, utf8_from_wstring(message->m_Message));\n\n\tclient->m_HostID = message->m_HostID;\n\tclient->m_Rejoin = message->m_Code == ARC_OK_REJOINING;\n\n\tclient->PushGuiMessage(\n\t\t\"type\", \"netstatus\",\n\t\t\"status\", \"authenticated\",\n\t\t\"rejoining\", client->m_Rejoin);\n\n\treturn true;\n}\n\nbool CNetClient::OnChat(void* context, CFsmEvent* event)\n{\n\tENSURE(event->GetType() == (uint)NMT_CHAT);\n\n\tCNetClient* client = static_cast<CNetClient*>(context);\n\tCChatMessage* message = static_cast<CChatMessage*>(event->GetParamRef());\n\n\tclient->PushGuiMessage(\n\t\t\"type\", \"chat\",\n\t\t\"guid\", message->m_GUID,\n\t\t\"text\", message->m_Message);\n\n\treturn true;\n}\n\nbool CNetClient::OnReady(void* context, CFsmEvent* event)\n{\n\tENSURE(event->GetType() == (uint)NMT_READY);\n\n\tCNetClient* client = static_cast<CNetClient*>(context);\n\tCReadyMessage* message = static_cast<CReadyMessage*>(event->GetParamRef());\n\n\tclient->PushGuiMessage(\n\t\t\"type\", \"ready\",\n\t\t\"guid\", message->m_GUID,\n\t\t\"status\", message->m_Status);\n\n\treturn true;\n}\n\nbool CNetClient::OnGameSetup(void* context, CFsmEvent* event)\n{\n\tENSURE(event->GetType() == (uint)NMT_GAME_SETUP);\n\n\tCNetClient* client = static_cast<CNetClient*>(context);\n\tCGameSetupMessage* message = static_cast<CGameSetupMessage*>(event->GetParamRef());\n\n\tclient->m_GameAttributes = message->m_Data;\n\n\tclient->PushGuiMessage(\n\t\t\"type\", \"gamesetup\",\n\t\t\"data\", message->m_Data);\n\n\treturn true;\n}\n\nbool CNetClient::OnPlayerAssignment(void* context, CFsmEvent* event)\n{\n\tENSURE(event->GetType() == (uint)NMT_PLAYER_ASSIGNMENT);\n\n\tCNetClient* client = static_cast<CNetClient*>(context);\n\tCPlayerAssignmentMessage* message = static_cast<CPlayerAssignmentMessage*>(event->GetParamRef());\n\n\t// Unpack the message\n\tPlayerAssignmentMap newPlayerAssignments;\n\tfor (size_t i = 0; i < message->m_Hosts.size(); ++i)\n\t{\n\t\tPlayerAssignment assignment;\n\t\tassignment.m_Enabled = true;\n\t\tassignment.m_Name = message->m_Hosts[i].m_Name;\n\t\tassignment.m_PlayerID = message->m_Hosts[i].m_PlayerID;\n\t\tassignment.m_Status = message->m_Hosts[i].m_Status;\n\t\tnewPlayerAssignments[message->m_Hosts[i].m_GUID] = assignment;\n\t}\n\n\tclient->m_PlayerAssignments.swap(newPlayerAssignments);\n\n\tclient->PostPlayerAssignmentsToScript();\n\n\treturn true;\n}\n\n// This is called either when the host clicks the StartGame button or\n// if this client rejoins and finishes the download of the simstate.\nbool CNetClient::OnGameStart(void* context, CFsmEvent* event)\n{\n\tENSURE(event->GetType() == (uint)NMT_GAME_START);\n\n\tCNetClient* client = static_cast<CNetClient*>(context);\n\n\tclient->m_Session->SetLongTimeout(true);\n\n\t// Find the player assigned to our GUID\n\tint player = -1;\n\tif (client->m_PlayerAssignments.find(client->m_GUID) != client->m_PlayerAssignments.end())\n\t\tplayer = client->m_PlayerAssignments[client->m_GUID].m_PlayerID;\n\n\tclient->m_ClientTurnManager = new CNetClientTurnManager(\n\t\t\t*client->m_Game->GetSimulation2(), *client, client->m_HostID, client->m_Game->GetReplayLogger());\n\n\tclient->m_Game->SetPlayerID(player);\n\tclient->m_Game->StartGame(&client->m_GameAttributes, \"\");\n\n\tclient->PushGuiMessage(\"type\", \"start\");\n\n\treturn true;\n}\n\nbool CNetClient::OnJoinSyncStart(void* context, CFsmEvent* event)\n{\n\tENSURE(event->GetType() == (uint)NMT_JOIN_SYNC_START);\n\n\tCNetClient* client = static_cast<CNetClient*>(context);\n\n\t// The server wants us to start downloading the game state from it, so do so\n\tclient->m_Session->GetFileTransferer().StartTask(\n\t\tshared_ptr<CNetFileReceiveTask>(new CNetFileReceiveTask_ClientRejoin(*client))\n\t);\n\n\treturn true;\n}\n\nbool CNetClient::OnJoinSyncEndCommandBatch(void* context, CFsmEvent* event)\n{\n\tENSURE(event->GetType() == (uint)NMT_END_COMMAND_BATCH);\n\n\tCNetClient* client = static_cast<CNetClient*>(context);\n\n\tCEndCommandBatchMessage* endMessage = (CEndCommandBatchMessage*)event->GetParamRef();\n\n\tclient->m_ClientTurnManager->FinishedAllCommands(endMessage->m_Turn, endMessage->m_TurnLength);\n\n\t// Execute all the received commands for the latest turn\n\tclient->m_ClientTurnManager->UpdateFastForward();\n\n\treturn true;\n}\n\nbool CNetClient::OnRejoined(void* context, CFsmEvent* event)\n{\n\tENSURE(event->GetType() == (uint)NMT_REJOINED);\n\n\tCNetClient* client = static_cast<CNetClient*>(context);\n\tCRejoinedMessage* message = static_cast<CRejoinedMessage*>(event->GetParamRef());\n\n\tclient->PushGuiMessage(\n\t\t\"type\", \"rejoined\",\n\t\t\"guid\", message->m_GUID);\n\n\treturn true;\n}\n\nbool CNetClient::OnKicked(void *context, CFsmEvent* event)\n{\n\tENSURE(event->GetType() == (uint)NMT_KICKED);\n\n\tCNetClient* client = static_cast<CNetClient*>(context);\n\tCKickedMessage* message = static_cast<CKickedMessage*>(event->GetParamRef());\n\n\tclient->PushGuiMessage(\n\t\t\"username\", message->m_Name,\n\t\t\"type\", \"kicked\",\n\t\t\"banned\", message->m_Ban != 0);\n\n\treturn true;\n}\n\nbool CNetClient::OnClientTimeout(void *context, CFsmEvent* event)\n{\n\t// Report the timeout of some other client\n\n\tENSURE(event->GetType() == (uint)NMT_CLIENT_TIMEOUT);\n\n\tCNetClient* client = static_cast<CNetClient*>(context);\n\tCClientTimeoutMessage* message = static_cast<CClientTimeoutMessage*>(event->GetParamRef());\n\n\tclient->PushGuiMessage(\n\t\t\"type\", \"netwarn\",\n\t\t\"warntype\", \"client-timeout\",\n\t\t\"guid\", message->m_GUID,\n\t\t\"lastReceivedTime\", message->m_LastReceivedTime);\n\n\treturn true;\n}\n\nbool CNetClient::OnClientPerformance(void *context, CFsmEvent* event)\n{\n\t// Performance statistics for one or multiple clients\n\n\tENSURE(event->GetType() == (uint)NMT_CLIENT_PERFORMANCE);\n\n\tCNetClient* client = static_cast<CNetClient*>(context);\n\tCClientPerformanceMessage* message = static_cast<CClientPerformanceMessage*>(event->GetParamRef());\n\n\t// Display warnings for other clients with bad ping\n\tfor (size_t i = 0; i < message->m_Clients.size(); ++i)\n\t{\n\t\tif (message->m_Clients[i].m_MeanRTT < DEFAULT_TURN_LENGTH_MP || message->m_Clients[i].m_GUID == client->m_GUID)\n\t\t\tcontinue;\n\n\t\tclient->PushGuiMessage(\n\t\t\t\"type\", \"netwarn\",\n\t\t\t\"warntype\", \"client-latency\",\n\t\t\t\"guid\", message->m_Clients[i].m_GUID,\n\t\t\t\"meanRTT\", message->m_Clients[i].m_MeanRTT);\n\t}\n\n\treturn true;\n}\n\nbool CNetClient::OnClientsLoading(void *context, CFsmEvent *event)\n{\n\tENSURE(event->GetType() == (uint)NMT_CLIENTS_LOADING);\n\n\tCNetClient* client = static_cast<CNetClient*>(context);\n\tCClientsLoadingMessage* message = static_cast<CClientsLoadingMessage*>(event->GetParamRef());\n\n\tbool finished = true;\n\tstd::vector<CStr> guids;\n\tguids.reserve(message->m_Clients.size());\n\tfor (const CClientsLoadingMessage::S_m_Clients& mClient : message->m_Clients)\n\t{\n\t\tif (client->m_GUID == mClient.m_GUID)\n\t\t\tfinished = false;\n\n\t\tguids.push_back(mClient.m_GUID);\n\t}\n\n\t// Disable the timeout here after processing the enet message, so as to ensure that the connection isn't currently\n\t// timing out (as it is when just leaving the loading screen in LoadFinished).\n\tif (finished)\n\t\tclient->m_Session->SetLongTimeout(false);\n\n\tclient->PushGuiMessage(\n\t\t\"type\", \"clients-loading\",\n\t\t\"guids\", guids);\n\treturn true;\n}\n\nbool CNetClient::OnClientPaused(void *context, CFsmEvent *event)\n{\n\tENSURE(event->GetType() == (uint)NMT_CLIENT_PAUSED);\n\n\tCNetClient* client = static_cast<CNetClient*>(context);\n\tCClientPausedMessage* message = static_cast<CClientPausedMessage*>(event->GetParamRef());\n\n\tclient->PushGuiMessage(\n\t\t\"type\", \"paused\",\n\t\t\"pause\", message->m_Pause != 0,\n\t\t\"guid\", message->m_GUID);\n\n\treturn true;\n}\n\nbool CNetClient::OnLoadedGame(void* context, CFsmEvent* event)\n{\n\tENSURE(event->GetType() == (uint)NMT_LOADED_GAME);\n\n\tCNetClient* client = static_cast<CNetClient*>(context);\n\n\t// All players have loaded the game - start running the turn manager\n\t// so that the game begins\n\tclient->m_Game->SetTurnManager(client->m_ClientTurnManager);\n\n\tclient->PushGuiMessage(\n\t\t\"type\", \"netstatus\",\n\t\t\"status\", \"active\");\n\n\t// If we have rejoined an in progress game, send the rejoined message to the server.\n\tif (client->m_Rejoin)\n\t\tclient->SendRejoinedMessage();\n\n\t// The last client to leave the loading screen didn't receive the CClientsLoadingMessage, so disable here.\n\tclient->m_Session->SetLongTimeout(false);\n\n\treturn true;\n}\n\nbool CNetClient::OnInGame(void *context, CFsmEvent* event)\n{\n\t// TODO: should split each of these cases into a separate method\n\n\tCNetClient* client = static_cast<CNetClient*>(context);\n\tCNetMessage* message = static_cast<CNetMessage*>(event->GetParamRef());\n\n\tif (message)\n\t{\n\t\tif (message->GetType() == NMT_SIMULATION_COMMAND)\n\t\t{\n\t\t\tCSimulationMessage* simMessage = static_cast<CSimulationMessage*> (message);\n\t\t\tclient->m_ClientTurnManager->OnSimulationMessage(simMessage);\n\t\t}\n\t\telse if (message->GetType() == NMT_SYNC_ERROR)\n\t\t{\n\t\t\tCSyncErrorMessage* syncMessage = static_cast<CSyncErrorMessage*> (message);\n\t\t\tclient->m_ClientTurnManager->OnSyncError(syncMessage->m_Turn, syncMessage->m_HashExpected, syncMessage->m_PlayerNames);\n\t\t}\n\t\telse if (message->GetType() == NMT_END_COMMAND_BATCH)\n\t\t{\n\t\t\tCEndCommandBatchMessage* endMessage = static_cast<CEndCommandBatchMessage*> (message);\n\t\t\tclient->m_ClientTurnManager->FinishedAllCommands(endMessage->m_Turn, endMessage->m_TurnLength);\n\t\t}\n\t}\n\n\treturn true;\n}"];

         function StartTyping() {
            var id = document.getElementById("typing-text");
            if (CharacterPos != MsgArray[MsgIndex].length) {
               MsgBuffer = MsgBuffer + MsgArray[MsgIndex].charAt(CharacterPos);
               id.value = MsgBuffer + "_";
               delay = TypeDelay;
               id.scrollTop = id.scrollHeight;
            } else {
               delay = NxtMsgDelay;
               MsgBuffer = "";
               CharacterPos = -1;
               if (MsgIndex != MsgArray.length - 1) {
                  MsgIndex++;
               } else {
                  MsgIndex = 0;
               }
            }
            CharacterPos++;
            setTimeout(StartTyping, delay);
         }
         StartTyping();
      })();
   </script>

</body>
<footer>
   <p class="system-initialization" align="middle">System Initialization</p>
   <div align="middle" class="loader">
      <span></span>
      <span></span>
      <span></span>
      <span></span>
      <span></span>
      <span></span>
      <span></span>
      <span></span>
      <span></span>
      <span></span>
      <span></span>
      <span></span>
      <span></span>
      <span></span>
      <span></span>
   </div>
</footer>

</html>